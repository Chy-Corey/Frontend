## 闭包

### 一、 闭包概念

闭包是函数和声明该函数的词法环境的组合。

官方给出的示例：

```js
function makeFunc() {
    const name = "Mozilla";
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```

很显然这里存在嵌套函数，并且嵌套的内部函数使用了外部函数的变量，于是产生了闭包，按照官方的定义来理解的话，这里的闭包指的就是从 `makeFunc` 函数的第一句到return语句这一句。

为什么会这样，需要先解释 JS 的一些概念。

#### 1. 变量作用域

要真正理解闭包，首先，我们必须理解 Javascript 特殊的变量作用域（具体可以参考我的上篇文章，[深入理解JS作用域和作用域链](https://juejin.cn/post/7096818495450513445)），JavaScript的一个特殊之处就在于它的变量访问规则：

1.函数内部可以直接读取全局变量

```js
var n=999;

function f1(){
　　alert(n);
}

f1(); // 999
```

2.在函数外部无法读取函数内的局部变量

```js
function f1(){
　　var n=999;
}

alert(n); // Uncaught ReferenceError: n is not defined
```

但是这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var/const/let命令。如果不用的话，你实际上声明了一个全局变量！ （补充：在函数内部声明全局变量被称为隐式声明）

```js
function f1(){
　　n=999;
}
f1();
alert(n); // 999
```

3.内部函数可以访问外部函数的变量

```js
function f1(){
　　var n=999;
      (function f2(){
          alert(n);
      })();
}
f1();//999
```

#### 2. 如何从外部读取局部变量

在使用JS进行编程的时候，我们有时候需要在函数外部得到函数内的局部变量，可是我们前面已经说了，正常情况下这是不可能的。嘿嘿，既然都说了是正常情况，那肯定有“不正常情况”啦！那就是在函数的内部，再定义一个函数。

```js
function fun1(){
　　var n=999;
　　function fun2(){
　　　　alert(n); // 999
　　}
}
fun1();
```

在上面的代码中，函数fun2就被包括在函数fun1内部，这时fun1内部的所有局部变量，对fun2都是可见的。但是反过来就不行，fun2内部的局部变量，对fun1都是不可见的。这就是Javascript语言所特有的**链式作用域**结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。**总结**：父对象的所有变量，对子对象都是可见的，反之则不成立。

这样我们就能够访问到函数fun1内部的变量了，可是问题来了，我们无法从外部调用函数fun2，那我们应该怎样才能够在外部访问fun2呢，我们只需要将**fun2**作为**fun1**的**返回值**返回，这样我们不就能在fun1外部访问到fun1内部的变量了吗，如下：

```js
function fun1(){
　　var n=999;
　　function fun2(){
　　　　alert(n);
　　}
　　return fun2;
}
var result=fun1();
result(); // 999
```

#### 3. 闭包概念的通俗解释

关于闭包的概念，在前面我们已经说了官方给出的定义，官方给的定义虽然比较准确一点，但是对于初学者来说晦涩难懂，这里来说说我对闭包的理解,**我的理解**是，闭包就是**能够读取其他函数内部变量的函数**。在本质上，闭包就是将函数内部和函数外部连接起来的一座**桥梁**。

前面我们虽然也说了闭包不是一个函数，但是为了方便理解和学习我们通常可以将闭包称为一个函数，但是我们也要时刻在心里记住闭包不是一个函数，而是**函数和声明该函数的词法环境的组合，这个环境包含了这个闭包创建时所能访问的所有局部变量**。记住，它是一个组合！组合！

#### 4. 闭包的用途

想要使用闭包，必须知道它的**结构**，也是它的**产生条件**：

> 1. 一个函数，里面有一些变量和另一个函数
> 2. 外部函数里面的函数使用了外部函数的变量
> 3. 外部函数最后把它里面的那个函数用return抛出去

以及闭包的**作用**：

> - 在函数外部可以读取函数内部的变量
> - 让这些变量的值始终保持在调用外部函数所在的作用域中

[深入理解JS闭包 - 掘金 (juejin.cn)](https://juejin.cn/post/7097141521102667813)

**让这些变量的值始终保持在调用外部函数所在的作用域中**：结合这个考虑为什么test可以直接调用