## 渲染原理

浏览器渲染的本质就是在网页上绘制出每个像素点对应的颜色，颜色是通过 HTML 和 CSS 指定的。

当浏览器收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

渲染流程分为多个阶段：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画。

上一阶段的输出会成为下一阶段的输入。

渲染的第一步是解析 HTML。解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到 script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM 树中。

### 一、构建DOM树

这个过程主要工作就是 **将HTML内容转换为浏览器DOM树结构**

#### 1. 什么是 DOM

**从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的**，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM

DOM树和HTML内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容，下图是HTML和DOM树的区别

![06-1](.\image\06-1.png)

**简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容**

#### 2. DOM树是怎么生成的

在渲染引擎内部，有一个 **HTML 解析器（HTMLParser）**，它的职责就是负责将 HTML 字节流转换为 DOM 结构

前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？参考下图

![06-2](.\image\06-2.png)

从图中可以看出，字节流转换为 DOM 需要三个阶段。

##### 转换Token

第一个阶段，通过分词器将字节流转换为 Token，分为 Tag Token 和文本 Token。

上述 HTML 代码通过词法分析生成的 Token 如下所示：

![06-3](E:\Note\fromTypora\Frontend\JS_supplement\image\06-3.png)

由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如图中的蓝色块就是 StartTag、红色块就是EndTag，文本 Token 对应的绿色块。

##### 解析和添加

至于后续的第二个和第三个阶段是同步进行的，**将 Token 解析为 DOM 节点**，**并将 DOM 节点添加到 DOM 树中**。

HTML 解析器维护了一个 **Token 栈结构**，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：

- HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底
- 如果压入到栈中的是 `StartTag Token`，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
- 如果分词器解析出来是`文本 Token`，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
- 如果分词器解析出来的是 `EndTag Token`，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

以下面HTML为例，看下整个过程

```html
<html>
  <body>
    <div>1</div>
    <div>test</div>
  </body>
</html>
```

HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：

![06-4](.\image\06-4.png)

然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：

![06-5](.\image\06-5.png)

接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：

![06-6](.\image\06-6.png)

再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示：

![06-7](.\image\06-7.png)

![06-8](.\image\06-8.png)

### 二、样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成

- 格式化样式表
- 标准化样式表
- 计算每个DOM节点具体样式

#### 1. 格式化样式表

对于CSS，浏览器拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构 styleSheets（CSSOM）

#### 2. 标准化样式表

```css
body { font-size: 2em }
p {color:blue;}
span {display: none}
div {font-weight: bold}
```

上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化，下面是转换后的属性

```css
body { font-size: 36px; }
p {color: rgb(0, 0, 255);}
span {display: none;}
div {font-weight: 700;}
```

#### 3. 计算每个DOM节点具体样式

主要分为两点

- 继承规则：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式
- 层叠规则：层叠是 CSS 的一个基本特征，比如：`.box p {}`

在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以 **通过JS来获取计算后的样式**

**样式计算的整个过程就是完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在`ComputedStyle`中**

#### 4. 生成布局树

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，也就是生成一颗**布局树（Layout Tree）**,之前说法叫**渲染树（Render Tree）**

Chrome 在布局阶段需要完成两个任务：创建 Layout Tree 和 布局计算

#### 5. 创建布局树（Layout Tree）

DOM 树还含有很多不可见的元素，比如 `head` 标签，还有使用了 `display:none `属性的元素。所以在显示之前，我们还要 **额外地构建一棵只包含可见元素的布局树`Layout Tree`**

结合下图来看看Layout Tree的构造过程：

![06-9](.\image\06-9.png)

从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中

为了构建布局树，浏览器大体上完成了下面这些工作：

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中
- 而不可见的节点会被布局树忽略掉，如 `head` 标签下面的全部内容，再比如` body.p.span` 这个元素，因为它的属性包含 `dispaly:none`，所以这个元素也没有被包进布局树

#### 6. 布局计算

浏览器根据 Layout Tree 所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置

Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为**回流（Reflow）**

### 三、分层（Layer）

浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的**图层树（Layer Tree）**

看看图层树与布局树之间关系

![06-10](.\image\06-10.png)

上图中的每一层，叫做**渲染层（PaintLayers）**

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层

那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？

#### 1. 渲染层

这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系

浏览器自动创建新的渲染层的条件有两个，一个是**满足层叠上下文**

**满足层叠上下文**：

- 根元素 document
- 有明确的定位属性（relative、fixed、sticky、absolute）
- opacity < 1
- 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画
- overflow 不为 visible
- 有 CSS transform 属性且值不为 none
- 有 CSS fliter 属性
- 有 CSS mask 属性
- 有 CSS mix-blend-mode 属性且值不为 normal
- backface-visibility 属性为 hidden
- 有 CSS reflection 属性
- 有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto

### 四、绘制图层绘制（Paint）

在完成渲染层的构建之后，渲染引擎会对每个渲染层进行绘制，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为 **重绘（Repaint）**

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

![06-11](.\image\06-11.png)

从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，**输出的内容就是这些待绘制列表**

到此 Paint 阶段执行完毕，开始 Compsite 阶段

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：

![06-12](.\image\06-12.png)

如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给**合成线程**

### 五、分块（tile）

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要

基于这个原因，**合成线程会将图层划分为图块（tile）**，这些图块的大小通常是 256x256 或者 512x512，然后合成线程会**按照视口附近的图块来优先生成位图**，实际生成位图的操作是由栅格化来执行的

### 六、栅格化（raster）

所谓栅格化，是指将图块转换为位图。即将这些信息进行位图填充，转化为像素值。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的

光栅化可以分为软件光栅化（Software Rasterization）和硬件光栅化（Hardware Rasterization）， 区别在于位图的生成是在 CPU 中进行，之后再上传至 GPU 合成，还是直接在 GPU 中进行绘图和图像素填充

当满足某些特殊条件的渲染层会被提升为合成层，而合成层的栅格化操作是在GPU中进行的。使用 GPU 生成位图的过程叫快速栅格化或硬件光栅化，生成的位图被保存在 GPU 内存中

GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式可以参考下图：

![06-13](.\image\06-13.png)

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后**在 GPU 中执行生成图块的位图（CompositingLayer）**，并保存在 GPU 的内存中

#### 1. 合成层（CompositingLayer）

满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。需要注意的点是 document 是渲染层，不是合成层

那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：

- 3D transforms：translate3d、translateZ 等
- video、canvas、iframe 等元素
- 通过 Element.animate() 实现的 opacity 动画转换
- 通过 СSS 动画实现的 opacity 动画转换
- position: fixed
- 具有 will-change 属性
- 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 正在执行 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）
- will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）
- 需要**剪裁**(clip)的地方

#### 2. 需要裁剪的地方

比如一个div标签很小，`50*50`像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层，也就是说这里会有三个图层，分别是div、文字、滚动条。如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1beb2e2bad5496da33dcc970f790a9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

#### 3. 合成层优缺点

优点

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快得多
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
- 元素提升为合成层后，transform 和 opacity 才不会触发 repaint，如果不是合成层，则其依然会触发 repaint

缺点

- 绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁
- 隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反。这个也叫做层爆炸（后面题目中会介绍）

#### 4. 图形层（GraphicsLayer）

GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上，**也就是说不会触发重绘和回流**。

所以 GraphicsLayer 是一个重要的渲染载体和工具，但它 **并不直接处理渲染层，而是处理合成层**

### 七、合成和显示

渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，一旦所有图块都被光栅化，会将结果返回给渲染进程的合成线程，执行合成图层操作（也就是创建合成层），图层合成完成后就会生成一个绘制的命令——“DrawQuad”，然后将该命令提交给浏览器进程

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，浏览器进程里会执行显示合成(Display Compositor)，也就是将**所有的图层**合成为页面内容。并将其绘制到显卡的后缓冲区。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e4242ae46944361824c69fc2716a324~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

#### 显示器显示图像的原理解释:

当通过渲染流水线通过GPU生成一张图片之后，会将图片存储到**显卡的后缓冲区**，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换；此时显示器会从前缓冲区中获取最新图片。一般情况下显示器的刷新频率是 60HZ，也就是每秒更新 60 张图片。

也就是说渲染流水线需要在16.66667ms内就要生成一张图片。显卡每16.66667ms就要交换一次缓冲区；如果生成图片过久，显示器就会读取不到新的图片，并保持上一帧图片；从而给用户造成视觉上的卡顿。

### 总结

一个完整的渲染流程大致可总结为如下：

- 渲染进程将 HTML 字节流转换为 DOM 树
- 渲染引擎将 CSS 样式表转化成styleSheets并根据层叠规则和继承规则计算出 DOM 节点的样式
- 创建布局树（Layout Tree），并计算元素的在页面中的几何信息
- 对Layout Tree进行分层，并生成图层树（Layer Tree）
- 为每个渲染层生成绘制列表，并将其提交到合成线程
- 合成线程将渲染层分成图块，并在光栅化线程池中通过 GPU 将图块转换成位图
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上